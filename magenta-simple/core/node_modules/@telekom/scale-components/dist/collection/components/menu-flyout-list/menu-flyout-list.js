/**
 * @license
 * Scale https://github.com/telekom/scale
 *
 * Copyright (c) 2021 Egor Kirpichev and contributors, Deutsche Telekom AG
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import { Component, Prop, h, Host, Method, Element, Event, Listen, State, } from '@stencil/core';
import classNames from 'classnames';
const name = 'menu-list';
export class MenuFlyoutList {
  /* 6. Lifecycle Events (call order) */
  constructor() {
    /* 2. State Variables (alphabetical) */
    /** Used to force a re-render */
    this.forceRender = 0;
    /** Flags to know if content scrollable */
    this.canScrollUp = false;
    this.canScrollDown = false;
    this.onMenuScroll = this.onMenuScroll.bind(this);
    this.onMenuWheel = this.onMenuWheel.bind(this);
  }
  connectedCallback() {
    this.resizeHandler();
  }
  componentWillLoad() { }
  componentWillUpdate() { }
  componentDidRender() { }
  componentDidLoad() { }
  componentDidUpdate() { }
  disconnectedCallback() { }
  /* 7. Listeners */
  resizeHandler() {
    // Get actual height for mobile where vh doesn't reflect whether URL bar showing or not
    this.hostElement.style.maxHeight = `calc(${window.innerHeight}px - 20px)`;
  }
  /* 8. Public Methods */
  /** Menu calls this once opened and rendered */
  async opened() {
    if (!this.menu) {
      return;
    }
    this.padForNonOverlayScrollbars();
    this.updateScrollIndicators();
  }
  /* 9. Local Methods */
  getCssClassMap() {
    return classNames(name, this.canScrollUp && `${name}--can-scroll-up`, this.canScrollDown && `${name}--can-scroll-down`);
  }
  // Add scrollbar width to menu, to avoid horizontal scrollbars or scrollbar forcing text-overflow
  // This affects firefox and safari, where non-overlay scrollbars eat into content width rather than add
  padForNonOverlayScrollbars() {
    this.menu.style.paddingRight = `0px`;
    const scrollbarWidth = this.menu.offsetWidth - this.menu.clientWidth;
    this.menu.style.paddingRight = `${scrollbarWidth}px`;
  }
  updateScrollIndicators() {
    // Reset
    this.canScrollDown = false;
    this.canScrollUp = false;
    const diff = this.menu.scrollHeight - this.menu.clientHeight;
    // Not scrollable
    if (diff) {
      if (this.menu.scrollTop > 0) {
        this.canScrollUp = true;
      }
      if (this.menu.scrollTop < diff) {
        this.canScrollDown = true;
      }
    }
    this.forceRender++;
  }
  onMenuScroll() {
    this.updateScrollIndicators();
  }
  // Check if going in a direction with content to reach, otherwise stop
  onMenuWheel(e) {
    // This is enough for chrome
    e.stopPropagation();
    // Needed for safari and firefox to prevent scrolling on non-scrollable lists
    if (!this.canScrollDown && !this.canScrollUp) {
      e.preventDefault();
    }
    // needed for safari to prevent scrolling past the end of a scrollable list
    if (e.deltaY > 0 && !this.canScrollDown) {
      e.preventDefault();
    }
    if (e.deltaY < 0 && !this.canScrollUp) {
      e.preventDefault();
    }
  }
  /* 10. Render */
  render() {
    return (h(Host, null,
      this.styles && h("style", null, this.styles),
      h("div", { class: this.getCssClassMap(), ref: (el) => (this.menu = el), part: "base", role: "menu", tabindex: "0", onScroll: this.onMenuScroll, onWheel: this.onMenuWheel },
        h("slot", null),
        h("div", { class: `${name}__scroll-up-indicator` }),
        h("div", { class: `${name}__scroll-down-indicator` }))));
  }
  static get is() { return "scale-menu-flyout-list"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["menu-flyout-list.css"]
  }; }
  static get styleUrls() { return {
    "$": ["menu-flyout-list.css"]
  }; }
  static get properties() { return {
    "styles": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "(optional) Injected styles"
      },
      "attribute": "styles",
      "reflect": false
    }
  }; }
  static get states() { return {
    "forceRender": {}
  }; }
  static get events() { return [{
      "method": "scaleSelect",
      "name": "scaleSelect",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Event triggered every time the data is edited, changing original rows data"
      },
      "complexType": {
        "original": "{\n    item: HTMLElement;\n  }",
        "resolved": "{ item: HTMLElement; }",
        "references": {
          "HTMLElement": {
            "location": "global"
          }
        }
      }
    }]; }
  static get methods() { return {
    "opened": {
      "complexType": {
        "signature": "() => Promise<void>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "Menu calls this once opened and rendered",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "hostElement"; }
  static get listeners() { return [{
      "name": "resize",
      "method": "resizeHandler",
      "target": "window",
      "capture": false,
      "passive": true
    }]; }
}
