import { r as registerInstance, h, H as Host, g as getElement, c as createEvent } from './index-5fb2d2c0.js';
import { c as classnames } from './index-349fc524.js';
import { s as statusNote } from './status-note-d227f142.js';

/**
 * @license
 * Scale https://github.com/telekom/scale
 *
 * Copyright (c) 2021 Egor Kirpichev and contributors, Deutsche Telekom AG
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
const hasShadowDom = (el) => {
  return !!el.shadowRoot && !!el.attachShadow;
};
// eg isPseudoClassSupported(':focus-visible') // true for chrome, false for safari
const isPseudoClassSupported = (pseudoClass) => {
  // Get the document stylesheet1
  let ss = document.styleSheets[0];
  // Create a stylesheet if one doesn't exist
  if (!ss) {
    const el = document.createElement('style');
    document.head.appendChild(el);
    ss = document.styleSheets[0];
    document.head.removeChild(el);
  }
  // Test the pseudo-class by trying to style with it
  function testPseudo() {
    try {
      if (!/^:/.test(pseudoClass)) {
        pseudoClass = ':' + pseudoClass;
      }
      ss.insertRule('html' + pseudoClass + '{}', 0);
      ss.deleteRule(0);
      return true;
    }
    catch (e) {
      return false;
    }
  }
  // Run the test
  return testPseudo();
};

const buttonCss = ":host{--width:auto;--spacing-x:var(--scl-spacing-24);--spacing-x-icon-only:var(--scl-spacing-8);--min-height:var(--scl-spacing-40);--radius:var(--scl-radius-8);--transition:all var(--scl-motion-duration-fast)\n    var(--scl-motion-easing-standard);--box-shadow-focus:0 0 0 var(--scl-spacing-2) var(--scl-color-focus);--font-weight:var(--scl-font-weight-bold);--font-size:var(--scl-font-size-16);--line-height:var(--scl-font-line-height-150);--spacing-icon-x:var(--scl-spacing-8);--vertical-align:middle;--font-size-small:var(--scl-font-size-12);--line-height-small:var(--scl-font-line-height-133);--min-height-small:var(--scl-spacing-32);--radius-primary:var(--radius);--background-primary:var(--scl-color-primary);--background-primary-hover:var(--scl-color-primary-hover);--background-primary-active:var(--scl-color-primary-active);--background-primary-disabled:var(--scl-color-background-disabled);--color-primary:var(--scl-color-white);--color-primary-disabled:var(--scl-color-grey-40);--radius-secondary:var(--radius);--border-width-secondary:var(--scl-spacing-1);--background-secondary:transparent;--color-secondary:var(--scl-color-text-standard);--color-secondary-hover:var(--scl-color-primary-hover);--color-secondary-active:var(--scl-color-primary-active);--color-secondary-disabled:var(--scl-color-background-disabled);--radius-ghost:var(--radius);--border-width-ghost:var(--scl-spacing-1);--spacing-x-ghost:var(--scl-spacing-8);--color-ghost:var(--scl-color-primary);--color-ghost-hover:var(--scl-color-primary-hover);--color-ghost-active:var(--scl-color-primary-active);--color-ghost-disabled:var(--scl-color-text-disabled)}.button{box-sizing:border-box;display:inline-flex;align-items:center;position:relative;border:0;outline:none;cursor:pointer;user-select:none;font-family:inherit;word-spacing:inherit;letter-spacing:inherit;justify-content:center;text-decoration:none;font-weight:var(--font-weight);font-size:var(--font-size);line-height:var(--line-height);min-height:var(--min-height);width:var(--width);padding-left:var(--spacing-x);padding-right:var(--spacing-x);vertical-align:var(--vertical-align);transition:var(--transition)}.button:not(.button--disabled):focus{box-shadow:var(--box-shadow-focus)}.button.button--icon-before ::slotted(*){margin-right:var(--spacing-icon-x)}.button.button--icon-after ::slotted(*){margin-left:var(--spacing-icon-x)}.button:after{top:0;left:0;width:100%;border:var(--scl-spacing-1) solid transparent;height:100%;content:'';display:block;position:absolute;box-sizing:border-box;pointer-events:none;border-radius:var(--radius)}.button--size-small{font-size:var(--font-size-small);line-height:var(--line-height-small);min-height:var(--min-height-small)}.button--icon-only{padding-left:var(--spacing-x-icon-only);padding-right:var(--spacing-x-icon-only)}.button--disabled{cursor:not-allowed}.button--variant-primary{text-align:center;border-radius:var(--radius);background:var(--background-primary);color:var(--color-primary)}.button--variant-primary:not(.button--disabled):hover{background:var(--background-primary-hover)}.button--variant-primary:not(.button--disabled):active{background:var(--background-primary-active)}.button--disabled.button--variant-primary{background:var(--background-primary-disabled);color:var(--color-primary-disabled)}.button--variant-secondary{background:var(--background-secondary);text-align:center;border-radius:var(--radius-secondary);border:var(--border-width-secondary) solid currentColor;color:var(--color-secondary)}.button--variant-secondary:not(.button--disabled):hover{color:var(--color-secondary-hover)}.button--variant-secondary:not(.button--disabled):active{color:var(--color-secondary-active)}.button--disabled.button--variant-secondary{color:var(--color-secondary-disabled)}.button--variant-ghost{background:transparent;text-align:center;border-radius:var(--radius-ghost);border:var(--border-width-ghost) solid transparent;color:var(--color-ghost);padding-left:var(--spacing-x-ghost);padding-right:var(--spacing-x-ghost)}.button--variant-ghost:not(.button--disabled):hover{color:var(--color-ghost-hover)}.button--variant-ghost:not(.button--disabled):active{color:var(--color-ghost-active)}.button--disabled.button--variant-ghost{color:var(--color-ghost-disabled)}";

const Button = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /** (optional) The size of the button */
    this.size = 'large';
    /** (optional) Button variant */
    this.variant = 'primary';
    /** (optional) If `true`, the button is disabled */
    this.disabled = false;
    /** (optional) Set to `true` when the button contains only an icon */
    this.iconOnly = false;
    /** (optional) Icon position related to the label */
    this.iconPosition = 'before';
    /** (optional) The target attribute for the <a> tag */
    this.target = '_self';
    /**
     * Hack to make the button behave has expected when inside forms.
     * @see https://github.com/ionic-team/ionic-framework/blob/master/core/src/components/button/button.tsx#L155-L175
     */
    this.handleClick = (ev) => {
      // No need to check for `disabled` because disabled buttons won't emit clicks
      if (hasShadowDom(this.hostElement)) {
        const form = this.hostElement.closest('form');
        if (form) {
          ev.preventDefault();
          const fakeButton = document.createElement('button');
          if (this.type) {
            fakeButton.type = this.type;
          }
          fakeButton.style.display = 'none';
          form.appendChild(fakeButton);
          fakeButton.click();
          fakeButton.remove();
        }
      }
    };
  }
  /**
   * Prevent clicks from being emitted from the host
   * when the component is `disabled`.
   */
  handleHostClick(event) {
    if (this.disabled === true) {
      event.stopImmediatePropagation();
    }
  }
  connectedCallback() {
    this.setIconPositionProp();
  }
  /**
   * Detect whether the last node is an element (not text).
   * If so, it's probably an icon, so we set `iconPosition` to `after`.
   */
  setIconPositionProp() {
    const nodes = Array.from(this.hostElement.childNodes);
    if (nodes.length < 2) {
      return;
    }
    const lastNode = nodes[nodes.length - 1];
    if (lastNode != null && lastNode.nodeType === 1) {
      this.iconPosition = 'after';
    }
  }
  render() {
    const basePart = classnames('base', this.variant && `variant-${this.variant}`, this.iconOnly && 'icon-only', !this.iconOnly && this.iconPosition, this.disabled && 'disabled');
    return (h(Host, null, this.styles && h("style", null, this.styles), this.href ? (h("a", { class: this.getCssClassMap(), href: this.href, target: this.target, rel: this.target === '_blank' ? 'noopener noreferrer' : undefined, "aria-label": this.ariaLabel, part: basePart }, h("slot", null))) : (h("button", { class: this.getCssClassMap(), onClick: this.handleClick, disabled: this.disabled, type: this.type, "aria-label": this.ariaLabel, part: basePart }, h("slot", null)))));
  }
  getCssClassMap() {
    return classnames('button', this.size && `button--size-${this.size}`, this.variant && `button--variant-${this.variant}`, this.iconOnly && `button--icon-only`, !this.iconOnly &&
      this.iconPosition &&
      `button--icon-${this.iconPosition}`, this.disabled && !this.href && `button--disabled`);
  }
  get hostElement() { return getElement(this); }
};
Button.style = buttonCss;

const checkboxCss = "scale-checkbox{--spacing-x:var(--scl-spacing-8);--transition:all var(--scl-motion-duration-fast)\n    var(--scl-motion-easing-standard);--color-text:var(--scl-color-text-standard);--color-error:var(--scl-color-text-error);--color-disabled:var(--scl-color-background-disabled);--color-standard:var(--scl-color-background-standard);--background-disabled:var(--scl-color-white);--color-primary:var(--scl-color-primary, #e20074);--color-focus:var(--scl-color-focus);--color-primary-hover:var(--scl-color-primary-hover, #f90984);--color-primary-active:var(--scl-color-primary-active, #cb0068);--width-control:var(--scl-spacing-16);--height-control:var(--scl-spacing-16);--transition-control:var(--transition);--spacing-control:var(--scl-spacing-2);--spacing-left-control:var(--scl-spacing-4);--radius-control:var(--scl-radius-4);--border-width-control:var(--scl-spacing-1);--transition-helper-text:var(--transition);--spacing-left-helper-text:calc(var(--width-control) + var(--spacing-x));--font-size-helper-text:var(--scl-font-size-12);--font-weight-helper-text:var(--scl-font-weight-bold);--line-height-helper-text:var(--scl-font-line-height-133);--color-helper-text:var(--scl-color-blue-70);--font-weight-label:var(--scl-font-weight-medium);--transition-label:var(--transition);--color-icon-checked-disabled:var(--scl-color-grey-30);--color-icon-checked-active:var(--scl-color-white);--width-icon:var(--scl-spacing-12);--height-icon:var(--scl-spacing-12);--left-icon:50%;--top-icon:50%;--transform-icon:translate(-50%, -50%)}.checkbox{position:relative;display:flex;flex-wrap:wrap;align-items:center}.checkbox .checkbox__control-wrapper{width:var(--width-control);height:var(--height-control);display:flex;position:relative;align-items:center;margin-right:var(--spacing-x)}.checkbox__label-wrapper{display:flex;flex-wrap:wrap;align-items:center}.checkbox .checkbox__label{color:var(--color-text);font-weight:var(--font-weight-label);transition:var(--transition-label)}.checkbox .checkbox__meta{width:100%;display:flex;justify-content:space-between}.checkbox .checkbox__helper-text{transition:var(--transition-helper-text);padding-left:var(--spacing-left-helper-text);font-size:var(--font-size-helper-text);font-weight:var(--font-weight-helper-text);line-height:var(--line-height-helper-text);color:var(--color-helper-text)}.checkbox--status-error .checkbox__helper-text{color:var(--color-error)}.checkbox input{width:0;height:0;opacity:0;position:absolute}.checkbox input:disabled~.checkbox__label{color:var(--color-disabled)}.checkbox input:checked:disabled~.checkbox__label{color:var(--color-disabled)}.checkbox input:checked:disabled~.checkbox__control-wrapper .checkbox__control{background:var(--color-disabled)}.checkbox input:checked:disabled~.checkbox__control-wrapper scale-icon-action-success{color:var(--color-icon-checked-disabled)}.checkbox input:checked:not([disabled]):hover~.checkbox__control-wrapper .checkbox__control,.checkbox input:checked:not([disabled])~.checkbox__control-wrapper:hover .checkbox__control{box-shadow:none;border-color:var(--color-primary-hover);background:var(--color-primary-hover)}.checkbox input:checked:not([disabled]):active~.checkbox__control-wrapper .checkbox__control,.checkbox input:checked:not([disabled])~.checkbox__control-wrapper:active .checkbox__control{border-color:var(--color-primary-active);background:var(--color-primary-active)}.checkbox input:checked:not([disabled]):active~.checkbox__control-wrapper scale-icon-action-success,.checkbox input:checked:not([disabled])~.checkbox__control-wrapper:active scale-icon-action-success{color:var(--color-icon-checked-active)}.checkbox input:checked:not([disabled])~.checkbox__control-wrapper .checkbox__control{border:var(--scl-spacing-1) solid var(--color-primary);background:var(--color-primary)}.checkbox input:disabled~.checkbox__control-wrapper .checkbox__control{border-color:var(--color-disabled)}.checkbox input:focus~.checkbox__control-wrapper .checkbox__control{box-shadow:0 0 0 var(--scl-spacing-2) var(--color-focus)}.checkbox input:not([disabled]):hover~.checkbox__control-wrapper .checkbox__control,.checkbox input:not([disabled])~.checkbox__control-wrapper:hover .checkbox__control{box-shadow:none;border-color:var(--color-primary-hover)}.checkbox input:not([disabled]):hover~.checkbox__control-wrapper~.checkbox__label,.checkbox input:not([disabled])~.checkbox__control-wrapper:hover~.checkbox__label{color:var(--color-primary-hover)}.checkbox input:not([disabled]):active~.checkbox__control-wrapper .checkbox__control,.checkbox input:not([disabled])~.checkbox__control-wrapper:active .checkbox__control{border-color:var(--color-primary-active);background:var(--color-primary-active)}.checkbox input:not([disabled]):active~.checkbox__control-wrapper scale-icon-action-success,.checkbox input:not([disabled])~.checkbox__control-wrapper:active scale-icon-action-success{color:var(--color-primary-active)}.checkbox input:not([disabled]):active~.checkbox__control-wrapper~.checkbox__label,.checkbox input:not([disabled])~.checkbox__control-wrapper:active~.checkbox__label{color:var(--color-primary-active)}.checkbox .checkbox__control-wrapper .checkbox__control{width:var(--width-control);height:var(--height-control);box-sizing:border-box;transition:var(--transition-control);border-radius:var(--radius-control);border:var(--border-width-control) solid var(--color-text);background:var(--color-standard)}.checkbox .checkbox__control-wrapper scale-icon-action-success{top:var(--top-icon);left:var(--left-icon);width:var(--width-icon);height:var(--height-icon);transform:var(--transform-icon);position:absolute;user-select:none;color:var(--color-standard)}.checkbox .checkbox__control-wrapper scale-icon-action-success svg{width:var(--width-icon);height:var(--height-icon)}.checkbox.checkbox--status-error .checkbox__control-wrapper .checkbox__control{border:var(--scl-spacing-2) solid var(--scl-color-background-error)}.checkbox--disabled .checkbox__label,.checkbox--disabled input,.checkbox--disabled .checkbox__control-wrapper,.checkbox--disabled .checkbox__helper-text{cursor:not-allowed;border-color:var(--color-disabled);color:var(--color-disabled);background:var(--background-disabled)}";

let i = 0;
const Checkbox = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.scaleChange = createEvent(this, "scaleChange", 7);
    /** (optional) Input name */
    this.name = '';
    /** (optional) Input label */
    this.label = '';
    /** (optional) Input helper text */
    this.helperText = '';
    /** (optional) Input status */
    this.status = '';
    /** (optional) Active switch */
    this.checked = false;
    /** (optional) Input value */
    this.value = '';
  }
  componentWillLoad() {
    if (this.inputId == null) {
      this.inputId = 'input-checkbox-' + i++;
    }
  }
  render() {
    const ariaInvalidAttr = this.status === 'error' ? { 'aria-invalid': true } : {};
    const helperTextId = `helper-message-${i}`;
    const ariaDescribedByAttr = { 'aria-describedBy': helperTextId };
    return (h(Host, { checked: this.checked }, h("div", { class: this.getCssClassMap() }, h("label", { class: "checkbox__label-wrapper", htmlFor: this.inputId }, h("input", Object.assign({ type: "checkbox", name: this.name, id: this.inputId, onChange: (e) => {
        this.checked = e.target.checked;
        // bubble event through the shadow dom
        this.scaleChange.emit({ value: this.checked });
      }, value: this.value, checked: this.checked, disabled: this.disabled }, ariaInvalidAttr, ariaDescribedByAttr)), h("div", { class: "checkbox__control-wrapper" }, h("span", { class: "checkbox__control" }), this.checked && (h("scale-icon-action-success", { decorative: true }))), h("span", { class: "checkbox__label" }, this.label ? this.label : h("slot", null)), !!this.helperText && (h("div", { class: "checkbox__meta", id: helperTextId, "aria-live": "polite", "aria-relevant": "additions removals" }, h("div", { class: "checkbox__helper-text" }, this.helperText)))))));
  }
  getCssClassMap() {
    return classnames('checkbox', this.checked && `checkbox--checked`, this.disabled && `checkbox--disabled`, this.status && `checkbox--status-${this.status}`);
  }
  get el() { return getElement(this); }
};
Checkbox.style = checkboxCss;

const dropdownCss = "scale-dropdown{--font-weight:var(--scl-font-weight-bold);--height:var(--scl-spacing-48);--height-small:var(--scl-spacing-40);--spacing-x:var(--scl-spacing-12);--spacing-dropdown:var(--scl-spacing-12) var(--scl-spacing-40) 0\n    calc(var(--spacing-x) - 1px);--transition:all var(--scl-motion-duration-fast)\n    var(--scl-motion-easing-standard);--radius:var(--scl-radius-4);--border:var(--scl-spacing-1) solid var(--scl-color-text-standard);--border-error:var(--scl-spacing-2) solid var(--scl-color-background-error);--border-color-hover:var(--scl-color-primary-hover, #f90984);--border-color-focus:var(--scl-color-primary-hover, #f90984);--box-shadow-focus:0 0 0 var(--scl-spacing-2) var(--scl-color-focus);--color-disabled:var(--scl-color-background-disabled);--background-disabled:var(--scl-color-white);--transition-input:var(--transition);--font-size-input:var(--scl-font-size-16);--transition-helper-text:var(--transition);--font-size-helper-text:var(--scl-font-size-12);--line-height-helper-text:var(--scl-font-line-height-133);--color-helper-text:var(--scl-color-blue-70);--color-helper-text-error:var(--scl-color-text-error);--spacing-y-meta:var(--scl-spacing-4);--color-meta:var(--scl-color-text-standard);--height-icon:var(--scl-spacing-24);--color-icon:var(--scl-color-text-standard);--color-icon-hover:var(--scl-color-primary-hover, #f90984);--color-icon-active:var(--scl-color-primary-active, #cb0068);--transition-icon:var(--transition);--color-label:var(--scl-color-grey-60);--z-index-label:var(--scl-z-index-10);--transition-label:var(--transition);--font-size-label:var(--scl-font-size-16);--font-size-label-small:var(--scl-font-size-16);--font-weight-label:var(--scl-font-weight-medium);--font-size-label-focus:var(--scl-font-size-10);--font-weight-label-focus:var(--scl-font-weight-bold)}.dropdown{position:relative}.dropdown .input__helper-text{font-weight:var(--font-weight)}.dropdown .input__dropdown{width:100%;height:var(--height);margin:0;display:flex;outline:none;padding:var(--spacing-dropdown);z-index:1;box-sizing:border-box;transition:var(--transition-input);font-family:inherit;font-size:var(--font-size-input);border-radius:var(--radius);border:var(--border);white-space:nowrap;text-overflow:ellipsis;appearance:none;-webkit-appearance:none}@-moz-document url-prefix(){.dropdown .input__dropdown{text-indent:-2px}}.dropdown .input__dropdown-wrapper{position:relative}.dropdown .input__helper-text{transition:var(--transition-helper-text);padding-left:var(--spacing-x);font-size:var(--font-size-helper-text);line-height:var(--line-height-helper-text);color:var(--color-helper-text)}.dropdown .input__meta{display:flex;justify-content:space-between;margin-top:var(--spacing-y-meta);color:var(--color-meta)}.dropdown.dropdown--disabled .input__dropdown-wrapper .input__dropdown-icon{color:var(--color-disabled)}.dropdown:not(.dropdown--disabled):hover .input__dropdown-icon{color:var(--color-icon-hover)}.dropdown:not(.dropdown--disabled):active .input__dropdown-icon{color:var(--color-icon-active)}.dropdown:not(.dropdown--disabled) .input__dropdown:hover{border-color:var(--border-color-hover)}.dropdown:not(.dropdown--disabled) .input__dropdown:focus{border-color:var(--border-color-focus)}.dropdown:not(.dropdown--disabled) .input__dropdown:focus{box-shadow:var(--box-shadow-focus)}.dropdown .input__dropdown-wrapper .input__dropdown-icon{top:50%;right:var(--spacing-x);position:absolute;transform:translateY(-50%);pointer-events:none;height:var(--height-icon);color:var(--color-icon);transition:var(--transition-icon)}.input__label{top:0;left:0;color:var(--color-label);display:flex;z-index:var(--z-index-label);position:absolute;transition:var(--transition-label);pointer-events:none;font-size:var(--font-size-label);transform:translate(\n    var(--spacing-x),\n    calc((var(--scl-spacing-48) - var(--font-size-label)) / 2)\n  );font-weight:var(--font-weight-label)}.animated .input__label{transform:translate(var(--spacing-x), var(--scl-spacing-8));font-size:var(--font-size-label-focus);font-weight:var(--font-weight-label-focus)}.dropdown--status-error .input__dropdown{border:var(--border-error)}.dropdown--status-error .input__helper-text{color:var(--color-helper-text-error)}.dropdown--size-small .input__dropdown{height:var(--height-small)}.dropdown--size-small .input__label{font-size:var(--font-size-label-small);transform:translate(\n    var(--spacing-x),\n    calc((var(--height-small) - var(--font-size-label-small)) / 2)\n  );font-weight:var(--font-weight-label-small)}.dropdown--size-small.animated .input__label{transform:translate(var(--spacing-x), var(--scl-spacing-4));font-size:var(--font-size-label-focus)}.dropdown--transparent .input__dropdown{background-color:transparent}.dropdown--disabled label,.dropdown--disabled .input__label,.dropdown--disabled input,.dropdown--disabled .input__dropdown,.dropdown--disabled .input__helper-text{cursor:not-allowed;border-color:var(--color-disabled);color:var(--color-disabled);background:var(--background-disabled)}";

let i$1 = 0;
const Dropdown = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.scaleInput = createEvent(this, "scaleInput", 7);
    this.scaleChange = createEvent(this, "scaleChange", 7);
    this.scaleFocus = createEvent(this, "scaleFocus", 7);
    this.scaleBlur = createEvent(this, "scaleBlur", 7);
    this.scaleKeyDown = createEvent(this, "scaleKeyDown", 7);
    /** (optional) Input name */
    this.name = '';
    /** (optional) Input label */
    this.label = '';
    /** (optional) Input size */
    this.size = '';
    /** (optional) Input helper text */
    this.helperText = '';
    /** (optional) Input status */
    this.status = '';
    /** (optional) Input value */
    this.value = '';
    /** (optional) Makes type `select` behave as a controlled component in React */
    this.controlled = false;
    // Handle change on <select> independently
    // so we can allow "controlled" (React) behavior,
    // in which only the `value` changing does update
    // the actual <select> value, not the user's input.
    this.handleSelectChange = (event) => {
      const target = event.target;
      if (this.controlled) {
        this.scaleChange.emit({ value: target.value });
        this.selectElement.value = String(this.value);
        this.forceUpdate = String(Date.now());
      }
      else {
        this.value = target.value || '';
        this.emitChange();
      }
    };
    this.handleInput = (event) => {
      const target = event.target;
      if (target) {
        this.value = target.value || '';
        this.emitChange();
      }
      this.scaleInput.emit(event);
    };
    this.handleChange = (event) => {
      const target = event.target;
      if (target) {
        this.value = target.value || '';
        this.emitChange();
      }
    };
    this.handleFocus = () => {
      this.scaleFocus.emit();
    };
    this.handleBlur = () => {
      this.scaleBlur.emit();
    };
    this.handleKeyDown = (event) => {
      this.scaleKeyDown.emit(event);
    };
  }
  componentWillLoad() {
    this.hasSlotIcon = !!this.hostElement.querySelector('[slot="icon"]');
    if (this.inputId == null) {
      this.inputId = 'input-dropdown' + i$1++;
    }
  }
  componentDidLoad() {
    // Keep this.value up-to-date for type="select".
    // This is important also for React, where `value` is used to control the element state.
    const select = this.selectElement;
    const selectedValue = select.selectedIndex > -1
      ? select.options[select.selectedIndex].value
      : null;
    // If we have a `value` passed, set it on the <select> element
    // Otherwise, if we have an <option selected>, set its value on `value`
    if (this.value) {
      select.value = String(this.value);
    }
    else if (selectedValue) {
      this.value = selectedValue;
    }
    // This is a workaroud to prevent a bug in Stencil:
    // when using slots without Shadow DOM (possible only with Stencil)
    // sometimes an update in the Light DOM does not trigger a re-render
    // thus causing unexpected results.
    // https://gitlab.com/scale-ds/scale-telekom/-/issues/16
    if (this.selectElement) {
      this.mutationObserver = new MutationObserver(() => {
        this.forceUpdate = String(Date.now());
      });
      this.mutationObserver.observe(this.hostElement, {
        childList: true,
        subtree: true,
      });
    }
  }
  componentDidUpdate() {
    this.hasSlotIcon = !!this.hostElement.querySelector('[slot="icon"]');
  }
  componentDidRender() {
    // When type `select` and `controlled` is true,
    // make sure the <select> is always in sync with the value.
    const value = this.value == null ? '' : this.value.toString();
    if (this.controlled && this.selectElement.value.toString() !== value) {
      this.selectElement.value = value;
    }
  }
  disconnectedCallback() {
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
    }
  }
  // We're not watching `value` like we used to
  // because we get unwanted `scaleChange` events
  // because how we keep this.value up-to-date for type="select"
  // `this.value = selectedValue`
  emitChange() {
    this.scaleChange.emit({
      value: this.value == null ? this.value : this.value.toString(),
    });
  }
  render() {
    const ariaInvalidAttr = this.status === 'error' ? { 'aria-invalid': true } : {};
    const helperTextId = `helper-message-${i$1}`;
    const ariaDescribedByAttr = { 'aria-describedBy': helperTextId };
    return (h(Host, null, h("div", { class: this.getCssClassMap() }, h("label", { class: "input__label", htmlFor: this.inputId }, this.label), h("div", { class: "input__dropdown-wrapper" }, h("select", Object.assign({ ref: (el) => (this.selectElement = el), class: "input__dropdown",
      // @ts-ignore
      value: this.value, onChange: this.handleSelectChange, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, disabled: this.disabled, required: this.required, multiple: this.multiple, id: this.inputId, name: this.name, size: this.visibleSize }, ariaInvalidAttr, ariaDescribedByAttr), h("slot", null)), h("div", { class: "input__dropdown-icon" }, this.hasSlotIcon ? (h("slot", { name: "icon" })) : (h("scale-icon-navigation-collapse-down", { decorative: true })))), !!this.helperText && (h("div", { class: "input__meta", id: helperTextId, "aria-live": "polite", "aria-relevant": "additions removals" }, !!this.helperText && (h("div", { class: "input__helper-text" }, this.helperText)))))));
  }
  getCssClassMap() {
    return classnames('dropdown', this.disabled && `dropdown--disabled`, this.transparent && 'dropdown--transparent', this.status && `dropdown--status-${this.status}`, this.size && `dropdown--size-${this.size}`, this.value != null && this.value !== '' && 'animated');
  }
  get hostElement() { return getElement(this); }
};
Dropdown.style = dropdownCss;

const ActionHidePassword = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /** (optional) The width and height in pixels */
    this.size = 24;
    /** (optional) Sets the icon color via the `fill` attribute */
    this.color = 'currentColor';
    /** (optional) If `true`, the icon changes visually */
    this.selected = false;
    /** (optional) If `true` the SVG element will get `aria-hidden="true"` */
    this.decorative = false;
  }
  connectedCallback() {
    if (!this.hostElement.hasAttribute('styles')) {
      this.hostElement.style.display = 'inline-flex';
    }
  }
  render() {
    const ariaHidden = this.decorative ? { 'aria-hidden': 'true' } : {};
    return (h(Host, null, h("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: this.size, height: this.size, viewBox: "0 0 24 24" }, ariaHidden), this.accessibilityTitle && h("title", null, this.accessibilityTitle), h("g", { fill: this.color }, this.selected ? (h("g", null, h("path", { "fill-rule": "evenodd", d: "M1.988 1.988A.75.75 0 013.03 1.97l17.25 17.25a.745.745 0 010 1.06.75.75 0 01-1.06 0L1.97 3.03a.75.75 0 01.018-1.042zM4.705 7.89l2.95 2.95A4.67 4.67 0 007.5 12a4.5 4.5 0 004.5 4.5 4.67 4.67 0 001.16-.155l2.285 2.28c-1.1.419-2.268.63-3.445.625-5.25 0-8.25-3.875-10.75-7.25a30.11 30.11 0 013.455-4.11zM12 4.75c5.25 0 8.25 3.875 10.75 7.25a30.11 30.11 0 01-3.455 4.11l-2.95-2.95c.1-.379.152-.768.155-1.16A4.5 4.5 0 0012 7.5a4.67 4.67 0 00-1.16.155l-2.285-2.28A9.562 9.562 0 0112 4.75zm-3 7.44l2.8 2.8a3 3 0 01-2.8-2.8zm3.2-3.18a3 3 0 012.8 2.8z" }))) : (h("g", null, h("path", { "fill-rule": "evenodd", d: "M2.85 2.85c.3-.3.75-.3 1.05 0L21.15 20.1c.3.3.3.75 0 1.05-.3.3-.75.3-1.05 0L2.85 3.9c-.3-.3-.3-.75 0-1.05zm1.35 4.5L5.25 8.4c-1.1 1.05-2.1 2.3-3.05 3.6 2.55 3.5 5.3 6.5 9.8 6.5 1.05 0 2-.15 2.85-.45L16 19.2c-1.2.5-2.5.8-4 .8-5.8 0-9.15-4.55-11.35-7.55L.3 12l.35-.45c.95-1.3 2.1-2.85 3.55-4.2zM12 4c5.8 0 9.15 4.55 11.35 7.55l.35.45-.35.45c-.95 1.3-2.1 2.85-3.55 4.2l-1.05-1.05c1.1-1.05 2.1-2.3 3.05-3.6-2.55-3.5-5.3-6.5-9.8-6.5-1.05 0-2 .15-2.85.45L8 4.8c1.2-.5 2.5-.8 4-.8zm-4.35 6.85l5.5 5.5c-.35.1-.75.15-1.15.15-2.5 0-4.5-2-4.5-4.5 0-.4.05-.8.15-1.15zM12 7.5c2.5 0 4.5 2 4.5 4.5 0 .4-.05.8-.15 1.15l-5.5-5.5c.35-.1.75-.15 1.15-.15z" })))))));
  }
  get hostElement() { return getElement(this); }
};

const ActionSort = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /** (optional) The width and height in pixels */
    this.size = 24;
    /** (optional) Sets the icon color via the `fill` attribute */
    this.color = 'currentColor';
    /** (optional) If `true`, the icon changes visually */
    this.selected = false;
    /** (optional) If `true` the SVG element will get `aria-hidden="true"` */
    this.decorative = false;
  }
  connectedCallback() {
    if (!this.hostElement.hasAttribute('styles')) {
      this.hostElement.style.display = 'inline-flex';
    }
  }
  render() {
    const ariaHidden = this.decorative ? { 'aria-hidden': 'true' } : {};
    return (h(Host, null, h("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: this.size, height: this.size, viewBox: "0 0 24 24" }, ariaHidden), this.accessibilityTitle && h("title", null, this.accessibilityTitle), h("g", { fill: this.color }, this.selected ? (h("g", null, h("path", { "fill-rule": "evenodd", d: "M17.25 3.5c.69 0 1.25.56 1.25 1.25V14h3.17l-4.42 6.75L12.83 14H16V4.75c0-.69.56-1.25 1.25-1.25zm-10.5-.25L11.17 10H8v9.25a1.25 1.25 0 11-2.5 0V10H2.33l4.42-6.75z" }))) : (h("g", null, h("path", { d: "M17.25 4c.4 0 .75.35.75.75V14h3.65l-4.4 6.75-4.4-6.75h3.65V4.75c0-.4.35-.75.75-.75zm-10.5-.75l4.4 6.75H7.5v9.25c0 .4-.35.75-.75.75S6 19.65 6 19.25V10H2.35z", "fill-rule": "evenodd" })))))));
  }
  get hostElement() { return getElement(this); }
};

const NavigationCollapseUp = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /** (optional) The width and height in pixels */
    this.size = 24;
    /** (optional) Sets the icon color via the `fill` attribute */
    this.color = 'currentColor';
    /** (optional) If `true`, the icon changes visually */
    this.selected = false;
    /** (optional) If `true` the SVG element will get `aria-hidden="true"` */
    this.decorative = false;
  }
  connectedCallback() {
    if (!this.hostElement.hasAttribute('styles')) {
      this.hostElement.style.display = 'inline-flex';
    }
  }
  render() {
    const ariaHidden = this.decorative ? { 'aria-hidden': 'true' } : {};
    return (h(Host, null, h("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: this.size, height: this.size, viewBox: "0 0 24 24" }, ariaHidden), this.accessibilityTitle && h("title", null, this.accessibilityTitle), h("g", { fill: this.color }, this.selected ? (h("g", null, h("path", { "fill-rule": "evenodd", d: "M20.12 17.31c-.332.001-.65-.13-.885-.365L12 9.71l-7.235 7.235A1.25 1.25 0 113 15.175l9-9 9 9a1.26 1.26 0 010 1.77c-.233.234-.55.365-.88.365z" }))) : (h("g", null, h("path", { d: "M20.1 16.8c-.2 0-.4-.05-.55-.2L12 9l-7.6 7.6c-.3.3-.75.3-1.05 0s-.3-.75 0-1.05L12 6.9l8.65 8.65c.3.3.3.75 0 1.05-.15.15-.35.2-.55.2z", "fill-rule": "evenodd" })))))));
  }
  get hostElement() { return getElement(this); }
};

const ServiceSettings = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /** (optional) The width and height in pixels */
    this.size = 24;
    /** (optional) Sets the icon color via the `fill` attribute */
    this.color = 'currentColor';
    /** (optional) If `true`, the icon changes visually */
    this.selected = false;
    /** (optional) If `true` the SVG element will get `aria-hidden="true"` */
    this.decorative = false;
  }
  connectedCallback() {
    if (!this.hostElement.hasAttribute('styles')) {
      this.hostElement.style.display = 'inline-flex';
    }
  }
  render() {
    const ariaHidden = this.decorative ? { 'aria-hidden': 'true' } : {};
    return (h(Host, null, h("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: this.size, height: this.size, viewBox: "0 0 24 24" }, ariaHidden), this.accessibilityTitle && h("title", null, this.accessibilityTitle), h("g", { fill: this.color }, this.selected ? (h("g", null, h("path", { "fill-rule": "evenodd", d: "M20.235 14.5L23 14v-4l-2.765-.5a1 1 0 01-.64-1.555l1.595-2.31-2.825-2.825-2.31 1.595a1 1 0 01-1.555-.64L14 1h-4l-.5 2.76a1 1 0 01-1.555.645L5.635 2.81 2.81 5.635l1.595 2.31a1 1 0 01-.64 1.555L1 10v4l2.76.5a1 1 0 01.645 1.555l-1.595 2.31 2.825 2.825 2.31-1.595a1 1 0 011.555.64L10 23h4l.5-2.765a1 1 0 011.555-.64l2.31 1.595 2.825-2.825-1.595-2.31a1 1 0 01.64-1.555zM12 15a3 3 0 110-6 3 3 0 010 6z" }))) : (h("g", null, h("path", { "fill-rule": "evenodd", d: "M14 1l.5 2.75c.15.75.95 1.05 1.55.65l2.3-1.6 2.85 2.85-1.6 2.3c-.4.6-.05 1.4.65 1.55L23 10v4l-2.75.5a.994.994 0 00-.65 1.55l1.6 2.3-2.85 2.85-2.3-1.6c-.6-.4-1.4-.05-1.55.65L14 23h-4l-.5-2.75c-.15-.7-.95-1.05-1.55-.65l-2.3 1.6-2.85-2.85 1.6-2.3c.4-.6.05-1.4-.65-1.55L1 14v-4l2.75-.5a.994.994 0 00.65-1.55l-1.6-2.3L5.65 2.8l2.3 1.6c.6.4 1.4.05 1.55-.65L10 1h4zm-1.25 1.5h-1.5l-.3 1.5c-.2 1.2-1.25 2.05-2.45 2.05-.5 0-1-.15-1.4-.45l-1.3-.9-1.05 1.05.9 1.3c.5.7.6 1.6.25 2.4-.3.8-1 1.35-1.85 1.5l-1.55.3v1.5l1.55.25c.85.15 1.5.7 1.85 1.5.35.8.25 1.7-.25 2.4l-.9 1.3 1.05 1.05 1.3-.9c.4-.3.9-.45 1.4-.45 1.2 0 2.25.85 2.45 2.05l.3 1.55h1.5l.3-1.55c.2-1.2 1.25-2.05 2.45-2.05.5 0 1 .15 1.4.45l1.3.9 1.05-1.05-.9-1.3c-.5-.7-.55-1.6-.25-2.3.3-.8 1-1.35 1.85-1.5l1.55-.3v-1.5l-1.55-.3c-.85-.15-1.5-.7-1.85-1.5-.35-.8-.25-1.7.25-2.4l.9-1.3-1.05-1.05-1.3.9c-.4.3-.9.45-1.4.45-1.2 0-2.25-.85-2.45-2.05l-.3-1.55zM12 9a3 3 0 110 6 3 3 0 010-6z" })))))));
  }
  get hostElement() { return getElement(this); }
};

const linkCss = ":host{--font-weight:var(--scl-font-weight-medium);--color:var(--scl-color-text-link);--color-visited:var(--scl-color-text-link-visited);--color-hover:var(--scl-color-text-link-hover);--color-active:var(--scl-color-text-link-active);--border:var(--scl-spacing-1) solid currentColor;--border-focus:var(--scl-spacing-2) solid currentColor;--color-disabled:var(--scl-color-grey-50);--spacing-x-icon:var(--scl-spacing-4)}.link{cursor:pointer;outline:none;text-decoration:none;font-weight:var(--font-weight);color:var(--color);border-bottom:var(--border)}.link:visited{color:var(--color-visited)}.link:hover{color:var(--color-hover)}.link:active{color:var(--color-active)}.link:focus:not(.link--disabled){border-bottom:var(--border-focus)}.link__wrapper{display:inline-flex;align-items:center}.link__wrapper>slot[name='icon']::slotted(*){margin-inline-start:var(--spacing-x-icon)}.link--block{display:block}.link--disabled{cursor:not-allowed;color:var(--color-disabled)}.link--disabled:visited,.link--disabled:hover,.link--disabled:active{color:var(--color-disabled)}";

const Link = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /** (optional) Disabled link */
    this.disabled = false;
    /** (optional) Block link */
    this.block = false;
    /** (optional) Link underline */
    // @Prop() underline?: boolean = true;
    /** (optional) Link open a new tag */
    this.target = '_self';
    /** (optional) Link variant */
    this.variant = '';
  }
  render() {
    return (h(Host, null, this.styles && h("style", null, this.styles), h("a", Object.assign({ class: this.getCssClassMap(), part: classnames('base', this.disabled && 'disabled'), href: this.disabled ? 'javascript:void(0)' : this.href }, (!this.disabled ? { target: this.target } : {}), { "aria-disabled": this.disabled }), h("span", { class: "link__wrapper", part: "wrapper" }, h("slot", null), h("slot", { name: "icon" })))));
  }
  getCssClassMap() {
    return classnames('link', this.disabled && 'link--disabled', this.block && 'link--block');
  }
};
Link.style = linkCss;

const menuFlyoutCss = ".menu{display:inline-block}.menu--cascaded{display:block}.menu__click-catcher{display:none;position:fixed;z-index:var(--scl-z-index-20);top:0;right:0;bottom:0;left:0}.menu--open .menu__click-catcher{display:block}.menu__trigger{display:inline-block}.menu--open .menu__trigger{z-index:var(--scl-z-index-20)}.menu__list-wrapper{position:fixed;pointer-events:none;z-index:var(--scl-z-index-20)}.menu__list{display:none;position:absolute;pointer-events:initial;z-index:var(--scl-z-index-20)}.menu--open .menu__list{display:block}.menu--flip-horizontal.menu--direction-bottom-left .menu__list,.menu--flip-vertical.menu--direction-top-right .menu__list,.menu--flip-horizontal.menu--flip-vertical.menu--direction-top-left .menu__list,.menu--direction-bottom-right .menu__list{top:calc(100% + var(--scl-spacing-4));left:0;right:auto;bottom:auto}.menu--flip-horizontal.menu--direction-bottom-right .menu__list,.menu--flip-vertical.menu--direction-top-left .menu__list,.menu--flip-horizontal.menu--flip-vertical.menu--direction-top-right .menu__list,.menu--direction-bottom-left .menu__list{top:calc(100% + var(--scl-spacing-4));right:0;left:auto;bottom:auto}.menu--flip-horizontal.menu--direction-top-left .menu__list,.menu--flip-vertical.menu--direction-bottom-right .menu__list,.menu--flip-horizontal.menu--flip-vertical.menu--direction-bottom-left .menu__list,.menu--direction-top-right .menu__list{bottom:calc(100% + var(--scl-spacing-4));left:0;right:auto;top:auto}.menu--flip-horizontal.menu--direction-top-right .menu__list,.menu--flip-vertical.menu--direction-bottom-left .menu__list,.menu--flip-horizontal.menu--flip-vertical.menu--direction-bottom-right .menu__list,.menu--direction-top-left .menu__list{bottom:calc(100% + var(--scl-spacing-4));right:0;left:auto;top:auto}.menu--flip-horizontal.menu--direction-left .menu__list,.menu--direction-right .menu__list{left:calc(100% - var(--scl-spacing-4));top:-20px;right:auto;bottom:auto}.menu--flip-horizontal.menu--direction-right .menu__list,.menu--direction-left .menu__list{right:calc(100% - var(--scl-spacing-4));top:-20px;left:auto;bottom:auto}.menu--cascaded .menu__click-catcher{z-index:-1}.menu--cascaded .menu__trigger{z-index:auto;display:block}.menu--cascaded .menu__list{z-index:auto}.menu--cascaded .menu__list-wrapper{z-index:auto}";

// [ ] Add keyboard controls
// [ ] Hover to open ?
// [ ] Trigger as contextual menu ?
// [ ] Fix ability to access parent menu 2 levels before (fixed nesting issue)
let idCounter = 0;
/** Number of pixels to leave as spacing from the edge of the window */
const PAD = 10;
const name = 'menu';
const MenuFlyout = class {
  /* 6. Lifecycle Events (call order) */
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.scaleOpen = createEvent(this, "scaleOpen", 7);
    this.scaleClose = createEvent(this, "scaleClose", 7);
    this.scaleSelect = createEvent(this, "scaleSelect", 7);
    /* 2. State Variables (alphabetical) */
    /** Used to force a re-render */
    this.forceRender = 0;
    /* 3. Public Properties (alphabetical) */
    /** (optional) Determines whether the dropdown should close when a menu item is selected */
    this.closeOnSelect = true;
    /** (optional) Tracks the menu list open state */
    this.open = false;
    /* 5. Private Properties (alphabetical) */
    /** Cascade level to help with closing when siblings are opened */
    this.cascadeLevel = 0;
    /** When menu off the screen horizontally */
    this.flipHorizontal = false;
    /** When menu off the screen vertically */
    this.flipVertical = false;
    /** Unique ID of component */
    this.id = idCounter++;
    /** True if menu a nested menu */
    this.isCascaded = false;
    /** Set true when resize or when opened */
    this.needsCheckPlacement = true;
    this.onCatcherClick = this.onCatcherClick.bind(this);
    this.onCatcherScroll = this.onCatcherScroll.bind(this);
    this.onTriggerClick = this.onTriggerClick.bind(this);
    this.onMenuClick = this.onMenuClick.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleKeyUp = this.handleKeyUp.bind(this);
  }
  connectedCallback() {
    // TODO: test cases where 16ms isn't enough - perhaps walk through children instead?
    // Need to wait a frame as possible parent slots may not have connected yet
    setTimeout(() => {
      this.calculateCascadeLevel();
      this.determineDefaultDirection();
    }, 16);
    statusNote({ source: this.hostElement, tag: 'beta' });
  }
  componentWillLoad() { }
  componentWillUpdate() { }
  componentWillRender() { }
  componentDidRender() {
    if (this.open && this.needsCheckPlacement) {
      // this.calculateCascadeLevel();
      // this.determineDefaultDirection();
      this.setListWrapperSize();
      // Notify menu-list so it can calculate scroll heights
      // @ts-ignore - No idea why it's complaining here, opened is a public method
      if (this.slottedList && this.slottedList.opened) {
        // @ts-ignore
        this.slottedList.opened();
      }
      this.checkPlacement();
    }
  }
  componentDidLoad() { }
  componentDidUpdate() { }
  disconnectedCallback() { }
  /* 7. Listeners */
  // Close menu on manual scrolls of parent elements (eg using page scroll bar or home/end keys)
  scrollHandler() {
    if (!this.open) {
      return;
    }
    // Force closed on scroll
    this.toggleOpenState();
  }
  resizeHandler() {
    if (!this.open) {
      return;
    }
    this.getWindowSize();
    // Force closed on resize
    this.toggleOpenState();
  }
  openHandler() {
    if (!this.open) {
      // Reset checks for boundary-aware placement
      this.needsCheckPlacement = true;
      this.flipHorizontal = false;
      this.flipVertical = false;
      this.list.style.marginLeft = '';
      this.list.style.marginTop = '';
      this.list.style.marginRight = '';
      this.list.style.marginBottom = '';
    }
    if (this.open) {
      this.getWindowSize();
      this.setListWrapperPosition();
    }
    this.updateTriggerAttributes();
  }
  // Listen for cascaded menu closes to also close
  childClosedHandler({ detail }) {
    // Ignore events from self
    if (detail.id === this.id) {
      return;
    }
    // Nested menu was closed, so also close without emitting
    this.open = false;
  }
  // Listen for cascaded menu closes to also close
  relativeOpenHandler({ detail }) {
    // Ignore events from self
    if (detail.id === this.id) {
      return;
    }
    if (!this.open || detail.cascadeLevel > this.cascadeLevel) {
      return;
    }
    // An adjacent menu thread was opened, so close without emitting
    this.open = false;
  }
  /* 8. Public Methods */
  /* 9. Local Methods */
  getCssClassMap() {
    return classnames(name, this.open && `${name}--open`, this.isCascaded && `${name}--cascaded`, `${name}--direction-${this.direction}`, this.flipHorizontal && `${name}--flip-horizontal`, this.flipVertical && `${name}--flip-vertical`);
  }
  calculateCascadeLevel() {
    let level = 0;
    let elem = this.hostElement;
    do {
      if (elem.tagName === 'SCALE-MENU-FLYOUT-LIST') {
        level++;
      }
      elem =
        // Check if shadow parent (slot)
        elem.assignedSlot ||
          // Check for regular parent
          elem.parentElement ||
          // Check if light parent (shadow dom host)
          elem.getRootNode().host;
    } while (elem);
    this.cascadeLevel = level;
    if (level > 0) {
      this.isCascaded = true;
    }
    // Need to re-render to store new direction state if cascaded
    this.forceRender++;
  }
  determineDefaultDirection() {
    // Default `bottom-right` for standalone menus, `right` for submenus
    if (!this.direction) {
      this.direction = this.isCascaded ? 'right' : 'bottom-right';
    }
  }
  getWindowSize() {
    this.windowWidth = window.innerWidth;
    this.windowHeight = window.innerHeight;
  }
  updateTriggerAttributes() {
    if (!this.triggerSlot) {
      return;
    }
    const slottedNodes = this.triggerSlot.assignedNodes();
    const slottedTrigger = slottedNodes.find((el) => el.nodeType !== Node.TEXT_NODE);
    if (!slottedTrigger) {
      return;
    }
    slottedTrigger.setAttribute('aria-haspopup', 'true');
    slottedTrigger.setAttribute('aria-expanded', this.open ? 'true' : 'false');
    // If trigger isn't a scale-menu-flyout-item this won't do anything
    slottedTrigger.active = this.open;
  }
  checkPlacement() {
    this.needsCheckPlacement = false;
    let isOutOfBounds = false;
    let rect = this.list.getBoundingClientRect();
    // Check horizontal flips
    if (rect.left < PAD) {
      // console.log('off left edge');
      isOutOfBounds = true;
      if (this.direction.includes('left')) {
        this.flipHorizontal = true;
      }
    }
    if (rect.right > this.windowWidth - PAD) {
      // console.log('off right edge');
      isOutOfBounds = true;
      if (this.direction.includes('right')) {
        this.flipHorizontal = true;
      }
    }
    // Check vertical flips
    if (rect.top < PAD) {
      // console.log('off top edge');
      isOutOfBounds = true;
      if (this.direction.includes('top')) {
        this.flipVertical = true;
      }
    }
    if (rect.bottom > this.windowHeight - PAD) {
      // console.log('off bottom edge');
      isOutOfBounds = true;
      if (this.direction.includes('bottom')) {
        this.flipVertical = true;
      }
    }
    // All good, can stop calculations
    if (!isOutOfBounds) {
      return;
    }
    // Apply flip class changes immediately to avoid frame flash
    this.main.className = this.getCssClassMap();
    // Force layout and style recalculation
    window.getComputedStyle(this.list);
    // Update rect for further tests
    rect = this.list.getBoundingClientRect();
    // TODO: add more functionality for order of priority of which edge to snap to
    // Shift to be snapped to a padded edge
    // Note can't use transform as it creates a relative parent for nested position fixed elements
    let left = 0;
    let top = 0;
    if (rect.left < PAD) {
      // console.log('still off left edge');
      left = PAD - rect.left;
    }
    else if (rect.right > this.windowWidth - PAD) {
      // console.log('still off right edge');
      left = this.windowWidth - PAD - rect.right;
    }
    if (rect.top < PAD) {
      // console.log('still off top edge');
      top = PAD - rect.top;
    }
    else if (rect.bottom > this.windowHeight - PAD) {
      // console.log('still off bottom edge');
      top = this.windowHeight - PAD - rect.bottom;
    }
    this.list.style.marginLeft = `${left}px`;
    this.list.style.marginTop = `${top}px`;
    this.list.style.marginRight = `${-left}px`;
    this.list.style.marginBottom = `${-top}px`;
    // Re-render visibly next frame with correct placement to update vdom
    setTimeout(() => this.forceRender++, 0);
  }
  // Need to manually set the list wrapper's size because
  // ancestors of cascaded menus cannot have position relative
  // or they will not allow interaction with ancestor menus
  setListWrapperSize() {
    if (!this.trigger) {
      return;
    }
    this.listWrapper.style.height = `${this.trigger.clientHeight}px`;
    this.listWrapper.style.width = `${this.trigger.clientWidth}px`;
  }
  // Because the wrapper is position: fixed due to overflow issues,
  // need to manually update position to match trigger
  setListWrapperPosition() {
    if (!this.trigger) {
      return;
    }
    const rect = this.trigger.getBoundingClientRect();
    this.listWrapper.style.top = `${rect.top}px`;
    this.listWrapper.style.left = `${rect.left}px`;
  }
  toggleOpenState() {
    this.open = !this.open;
    this.emitOpenState();
  }
  emitOpenState() {
    const { id, cascadeLevel } = this;
    if (this.open) {
      this.scaleOpen.emit({ id, cascadeLevel });
    }
    else {
      this.scaleClose.emit({ id, cascadeLevel });
    }
  }
  onCatcherClick(e) {
    e.preventDefault();
    this.toggleOpenState();
  }
  onCatcherScroll() {
    if (this.open) {
      this.toggleOpenState();
    }
  }
  onTriggerClick() {
    // Prevent clicks on open submenu closing menu
    if (this.cascadeLevel && this.open) {
      return;
    }
    this.toggleOpenState();
  }
  onMenuClick(event) {
    const target = event.target;
    // See if click was on a nested menu item
    const item = target.closest('scale-menu-flyout-item');
    // Make sure isn't disabled or a cascading menu
    if (item && !item.disabled && !item.cascade) {
      // Send event in case developer listening on the menu and not items individually
      this.scaleSelect.emit({ item });
      if (this.closeOnSelect) {
        this.toggleOpenState();
      }
    }
    // Stop bubbling up to possible parent menus
    event.stopPropagation();
  }
  handleKeyDown(e) {
    const { key } = e;
    // console.log(key);
    // When up/down is pressed, we make the assumption that the user is familiar with the menu and plans to make a
    // selection. Rather than toggle the panel, we focus on the menu (if one exists) and activate the first item for
    // faster navigation.
    if (['ArrowDown', 'ArrowUp'].includes(key)) {
      e.preventDefault();
      // Show the menu if it's not already open
      if (!this.open) {
        this.toggleOpenState();
      }
    }
  }
  handleKeyUp() { }
  /* 10. Render */
  render() {
    return (h(Host, null, this.styles && h("style", null, this.styles), h("div", { class: this.getCssClassMap(), ref: (el) => (this.main = el),
      // onClick={this.handleClick}
      onKeyDown: this.handleKeyDown, onKeyUp: this.handleKeyUp }, h("div", { class: `${name}__click-catcher`, onTouchStart: this.onCatcherClick, onClick: this.onCatcherClick, onKeyDown: this.onCatcherClick, onKeyUp: this.onCatcherClick, onWheel: this.onCatcherScroll }), h("div", { class: `${name}__list-wrapper`, ref: (el) => (this.listWrapper = el) }, h("div", { class: `${name}__list`, ref: (el) => (this.list = el), onClick: this.onMenuClick }, h("slot", { onSlotchange: (e) => {
        this.listSlot = e.target;
        const slottedNodes = this.listSlot.assignedNodes();
        const slottedList = slottedNodes.find((el) => el.nodeType !== Node.TEXT_NODE);
        if (slottedList) {
          this.slottedList = slottedList;
        }
      } }))), h("span", { class: `${name}__trigger`, onClick: this.onTriggerClick, ref: (el) => (this.trigger = el) }, h("slot", { name: "trigger", onSlotchange: (e) => {
        this.triggerSlot = e.target;
        this.updateTriggerAttributes();
      } })))));
  }
  get hostElement() { return getElement(this); }
  static get watchers() { return {
    "open": ["openHandler"]
  }; }
};
MenuFlyout.style = menuFlyoutCss;

const menuFlyoutItemCss = ":host{display:block}*{-webkit-tap-highlight-color:rgba(255, 255, 255, 0)}.menu-item{display:flex;align-items:stretch;text-align:left;font-size:var(--scl-font-size-16);line-height:2.635em;padding:0 var(--scl-spacing-24);user-select:none;white-space:nowrap;border-radius:var(--scl-radius-4);cursor:pointer;color:var(--scl-color-black);max-width:calc(100vw - 2 * var(--scl-spacing-24) - 2 * 10px);overflow:hidden;min-width:fit-content;min-width:-moz-fit-content}.menu-item--focused:not(.menu-item--disabled),.menu-item--active:not(.menu-item--disabled){outline:none;color:var(--scl-color-primary-hover)}.menu-item--disabled{outline:none;color:#ccc;cursor:not-allowed}.menu-item__label{flex:1 1 0;overflow:hidden;text-overflow:ellipsis}.menu-item__prefix{flex:0 0 auto;display:flex;align-items:center}.menu-item__check,slot[name='prefix']::slotted(:last-of-type){margin-right:var(--scl-spacing-8)}.menu-item__suffix{flex:0 0 auto;display:flex;align-items:center}.menu-item__cascade,slot[name='suffix']::slotted(:first-of-type){margin-left:var(--scl-spacing-16)}";

const name$1 = 'menu-item';
const MenuFlyoutItem = class {
  /* 6. Lifecycle Events (call order) */
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /* 2. State Variables (alphabetical) */
    this.hasFocus = false;
    /* 3. Public Properties (alphabetical) */
    /** (optional) Used by cascading menus to set when open */
    this.active = false;
    /** (optional) Set to true to display arrow icon suffix */
    this.cascade = false;
    /** (optional) Disabled */
    this.disabled = false;
  }
  connectedCallback() { }
  componentWillLoad() { }
  componentWillUpdate() { }
  componentDidRender() { }
  componentDidLoad() { }
  componentDidUpdate() { }
  disconnectedCallback() { }
  /* 7. Listeners */
  /* 8. Public Methods */
  /** Sets the focus on the item */
  async setFocus() {
    this.menuItem.focus();
  }
  /** Removes the focus from the item */
  async removeFocus() {
    this.menuItem.blur();
  }
  /* 9. Local Methods */
  getCssClassMap() {
    return classnames(name$1, this.disabled && `${name$1}--disabled`, this.hasFocus && `${name$1}--focused`, this.active && `${name$1}--active`);
  }
  /* 10. Render */
  render() {
    return (h(Host, null, this.styles && h("style", null, this.styles), h("div", { class: this.getCssClassMap(), ref: (el) => (this.menuItem = el), part: "base", role: "menuitem", tabindex: "-1", "aria-disabled": this.disabled ? 'true' : 'false', onFocus: () => (this.hasFocus = true), onBlur: () => (this.hasFocus = false), onMouseEnter: () => this.setFocus(), onMouseLeave: () => this.removeFocus(), onTouchStart: () => this.setFocus(), onTouchEnd: () => this.removeFocus() }, h("span", { part: "prefix", class: `${name$1}__prefix` }, this.checked === undefined ? (h("slot", { name: "prefix" })) : (h("scale-icon-action-success", { class: `${name$1}__check`, style: {
        opacity: !this.checked || this.checked === 'false' ? '0' : '1',
      }, size: 16 }))), h("span", { part: "label", class: `${name$1}__label` }, h("slot", null)), h("span", { part: "suffix", class: `${name$1}__suffix` }, this.cascade ? (h("scale-icon-navigation-right", { class: `${name$1}__cascade`, size: 16, slot: "suffix" })) : (h("slot", { name: "suffix" }))))));
  }
  get hostElement() { return getElement(this); }
};
MenuFlyoutItem.style = menuFlyoutItemCss;

const menuFlyoutListCss = ":host{display:inline-flex;background:var(--scl-color-white);border-radius:var(--scl-radius-8);box-shadow:var(--scl-shadow-level-4);overflow-y:hidden}.menu-list{padding:20px 0;overflow-y:auto;overflow-y:overlay;overscroll-behavior:contain}.menu-list:focus{outline:none}.menu-list__scroll-up-indicator,.menu-list__scroll-down-indicator{position:absolute;width:0;border:5px solid transparent;pointer-events:none;opacity:0;left:50%}.menu-list__scroll-up-indicator{top:var(--scl-spacing-8);border-bottom:5px solid var(--scl-color-grey-40);border-top:0}.menu-list__scroll-down-indicator{bottom:var(--scl-spacing-8);border-top:5px solid var(--scl-color-grey-40);border-bottom:0}.menu-list--can-scroll-up .menu-list__scroll-up-indicator{opacity:1}.menu-list--can-scroll-down .menu-list__scroll-down-indicator{opacity:1}";

const name$2 = 'menu-list';
const MenuFlyoutList = class {
  /* 6. Lifecycle Events (call order) */
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.scaleSelect = createEvent(this, "scaleSelect", 7);
    /* 2. State Variables (alphabetical) */
    /** Used to force a re-render */
    this.forceRender = 0;
    /** Flags to know if content scrollable */
    this.canScrollUp = false;
    this.canScrollDown = false;
    this.onMenuScroll = this.onMenuScroll.bind(this);
    this.onMenuWheel = this.onMenuWheel.bind(this);
  }
  connectedCallback() {
    this.resizeHandler();
  }
  componentWillLoad() { }
  componentWillUpdate() { }
  componentDidRender() { }
  componentDidLoad() { }
  componentDidUpdate() { }
  disconnectedCallback() { }
  /* 7. Listeners */
  resizeHandler() {
    // Get actual height for mobile where vh doesn't reflect whether URL bar showing or not
    this.hostElement.style.maxHeight = `calc(${window.innerHeight}px - 20px)`;
  }
  /* 8. Public Methods */
  /** Menu calls this once opened and rendered */
  async opened() {
    if (!this.menu) {
      return;
    }
    this.padForNonOverlayScrollbars();
    this.updateScrollIndicators();
  }
  /* 9. Local Methods */
  getCssClassMap() {
    return classnames(name$2, this.canScrollUp && `${name$2}--can-scroll-up`, this.canScrollDown && `${name$2}--can-scroll-down`);
  }
  // Add scrollbar width to menu, to avoid horizontal scrollbars or scrollbar forcing text-overflow
  // This affects firefox and safari, where non-overlay scrollbars eat into content width rather than add
  padForNonOverlayScrollbars() {
    this.menu.style.paddingRight = `0px`;
    const scrollbarWidth = this.menu.offsetWidth - this.menu.clientWidth;
    this.menu.style.paddingRight = `${scrollbarWidth}px`;
  }
  updateScrollIndicators() {
    // Reset
    this.canScrollDown = false;
    this.canScrollUp = false;
    const diff = this.menu.scrollHeight - this.menu.clientHeight;
    // Not scrollable
    if (diff) {
      if (this.menu.scrollTop > 0) {
        this.canScrollUp = true;
      }
      if (this.menu.scrollTop < diff) {
        this.canScrollDown = true;
      }
    }
    this.forceRender++;
  }
  onMenuScroll() {
    this.updateScrollIndicators();
  }
  // Check if going in a direction with content to reach, otherwise stop
  onMenuWheel(e) {
    // This is enough for chrome
    e.stopPropagation();
    // Needed for safari and firefox to prevent scrolling on non-scrollable lists
    if (!this.canScrollDown && !this.canScrollUp) {
      e.preventDefault();
    }
    // needed for safari to prevent scrolling past the end of a scrollable list
    if (e.deltaY > 0 && !this.canScrollDown) {
      e.preventDefault();
    }
    if (e.deltaY < 0 && !this.canScrollUp) {
      e.preventDefault();
    }
  }
  /* 10. Render */
  render() {
    return (h(Host, null, this.styles && h("style", null, this.styles), h("div", { class: this.getCssClassMap(), ref: (el) => (this.menu = el), part: "base", role: "menu", tabindex: "0", onScroll: this.onMenuScroll, onWheel: this.onMenuWheel }, h("slot", null), h("div", { class: `${name$2}__scroll-up-indicator` }), h("div", { class: `${name$2}__scroll-down-indicator` }))));
  }
  get hostElement() { return getElement(this); }
};
MenuFlyoutList.style = menuFlyoutListCss;

const paginationCss = ":host{--color:var(--scl-color-black);--font-size:var(--scl-font-size-16);--border:1px solid var(--scl-color-grey-10);--color-hover:var(--scl-color-primary-hover);--color-button:var(--scl-color-grey-10);--border-button:var(--border);--box-shadow-focus:0px 0px 0px 2px var(--scl-color-focus);--radius-first-prompt:12px 0 0 12px;--radius-last-prompt:0 12px 12px 0;--stroke-svg:var(--scl-color-black)}.pagination{display:inline-flex}.pagination__info{color:var(--color);text-align:center;font-size:var(--font-size);line-height:52px;padding:0 15px;border:var(--border);flex-shrink:0;border-left:0;border-right:0}.pagination__info span{font-weight:bold}button{display:flex;flex-shrink:0;justify-content:center;align-items:center;padding:0;margin:0;height:54px;width:42px;color:var(--color-button);background:none;border:var(--border-button)}button:focus{outline:none;box-shadow:var(--box-shadow-focus)}.pagination__first-prompt{border-radius:var(--radius-first-prompt);margin-right:-1px}.pagination__last-prompt{border-radius:var(--radius-last-prompt);margin-left:-1px}button svg{display:block}button:not(:disabled){cursor:pointer}button:not(:disabled) svg{stroke:var(--stroke-svg)}button:not(:disabled):hover{border-color:var(--color-hover);z-index:1}button:not(:disabled):hover svg{stroke:var(--color-hover)}.pagination--hide-borders .pagination__info{border:0}.pagination--hide-borders button{border-radius:0;border-top-width:0;border-bottom-width:0}.pagination--hide-borders button:not(:disabled):hover{border-width:1px !important;border-color:var(--color-hover) !important}";

/*
  TODO
  ====
  [ ] Support pages text as well as elements eg `page 1 / 5` vs `1 - 12 / 100`
  [ ] Add Pages drop-down (awaiting menu and menu-list components)
  [ ] Add text input option for choosing currernt page/start element
  [ ] Add events for specific button interactions (first, prev, next, last)
  [ ] Add :focus-visible support to avoid focus upon click in chrome
  [ ] Add accessibility attributes
  [ ] Add icons to the icon components ?
*/
const name$3 = 'pagination';
const Pagination = class {
  /* 6. Lifecycle Events (call order) */
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.scalePagination = createEvent(this, "scalePagination", 7);
    /* 2. State Variables (alphabetical) */
    /* 3. Public Properties (alphabetical) */
    /** (optional) Set to true to hide top and bottom borders */
    this.hideBorders = false;
    /** (optional) Set number of rows/elements to show per page */
    this.pageSize = 10;
    /** (optional) Index of first element to display */
    this.startElement = 0;
    /** (optional) Total number of rows/elements used to calculate page displays */
    this.totalElements = 1;
    /* 5. Private Properties (alphabetical) */
    /** Calculated width of largest text so buttons don't move while changing pages */
    this.maxWidth = 100;
  }
  connectedCallback() {
    statusNote({ source: this.hostElement, tag: 'beta' });
  }
  componentWillLoad() {
    this.calculateWidth();
  }
  componentWillUpdate() { }
  componentDidRender() { }
  componentDidLoad() { }
  componentDidUpdate() { }
  disconnectedCallback() { }
  /* 7. Listeners */
  calculateWidth() {
    // calculate max possible width
    this.maxWidth = (this.totalElements.toString().length * 3 + 3) * 9;
  }
  /* 8. Public Methods */
  /* 9. Local Methods */
  goFirstPage() {
    this.startElement = 0;
    this.emitUpdate();
  }
  goPreviousPage() {
    // Min to prevent going below 0
    this.startElement -= Math.min(this.pageSize, this.startElement);
    this.emitUpdate();
  }
  goNextPage() {
    this.startElement += this.pageSize;
    this.emitUpdate();
  }
  goLastPage() {
    const p = this.pageSize;
    // Make sure startElement is multiple of pageSize
    this.startElement = Math.ceil((this.totalElements - p) / p) * p;
    this.emitUpdate();
  }
  emitUpdate() {
    const data = {
      startElement: this.startElement,
    };
    this.scalePagination.emit(data);
  }
  /* 10. Render */
  render() {
    const total = this.totalElements;
    const start = this.startElement + 1;
    const end = Math.min(this.startElement + this.pageSize, total);
    const isAtStart = start === 1;
    const isAtEnd = end === total;
    return (h(Host, null, this.styles && h("style", null, this.styles), h("div", { part: this.getBasePartMap(), class: this.getCssClassMap() }, h("button", { class: `${name$3}__first-prompt`, part: "first-prompt", disabled: isAtStart, onClick: () => this.goFirstPage() }, h("svg", { height: "17", viewBox: "0 0 48 52", fill: "none", xmlns: "http://www.w3.org/2000/svg", stroke: "#cacaca" }, h("path", { d: "M44.5 48.5L21.5 26L44.5 3.5M27.5 48.5L4.5 26L27.5 3.5", "stroke-width": "6", "stroke-linecap": "round" }))), h("button", { class: `${name$3}__prev-prompt`, part: "prev-prompt", disabled: isAtStart, onClick: () => this.goPreviousPage() }, h("svg", { height: "17", viewBox: "0 0 37 52", fill: "none", xmlns: "http://www.w3.org/2000/svg", stroke: "#cacaca" }, h("path", { d: "M33 48L6 26L33 4", "stroke-width": "7", "stroke-linecap": "round" }))), h("div", { part: "info", class: `${name$3}__info`, style: { width: `${this.maxWidth}px` } }, h("span", null, start, "-", end), ' ', "/ ", total), h("button", { class: `${name$3}__next-prompt`, part: "next-prompt", disabled: isAtEnd, onClick: () => this.goNextPage() }, h("svg", { height: "17", viewBox: "0 0 37 52", fill: "none", xmlns: "http://www.w3.org/2000/svg", stroke: "#cacaca" }, h("path", { d: "M4 4L31 26L4 48", "stroke-width": "7", "stroke-linecap": "round" }))), h("button", { class: `${name$3}__last-prompt`, part: "last-prompt", disabled: isAtEnd, onClick: () => this.goLastPage() }, h("svg", { height: "17", viewBox: "0 0 48 52", fill: "none", xmlns: "http://www.w3.org/2000/svg", stroke: "#cacaca" }, h("path", { d: "M3.5 3.5L26.5 26L3.5 48.5M20.5 3.5L43.5 26L20.5 48.5", "stroke-width": "6", "stroke-linecap": "round" }))))));
  }
  getBasePartMap() {
    return this.getCssOrBasePartMap('basePart');
  }
  getCssClassMap() {
    return this.getCssOrBasePartMap('css');
  }
  getCssOrBasePartMap(mode) {
    const prefix = mode === 'basePart' ? '' : `${name$3}--`;
    return classnames(name$3, this.hideBorders && `${prefix}hide-borders`);
  }
  get hostElement() { return getElement(this); }
  static get watchers() { return {
    "totalElements": ["calculateWidth"]
  }; }
};
Pagination.style = paginationCss;

const progressBarCss = ":host{--color-error:var(--scl-color-text-error);--color-disabled:var(--scl-color-grey-50);--background:var(--scl-color-primary);--color-inner-status:var(--scl-color-background-standard);--font-size-inner-status:var(--scl-font-size-12);--font-size-status:var(--scl-font-size-12);--font-weight-status:var(--scl-font-weight-extrabold);--color-status:var(--scl-color-grey-60);--color-status-description:var(--scl-color-grey-60);--font-size-status-description:var(--scl-font-size-12);--font-weight-status-description:var(--scl-font-weight-bold);--spacing-label:var(--scl-spacing-8) 0;--border:1px solid var(--scl-color-grey-60)}.progress-bar{width:100%;max-width:30rem}.progress-bar--has-error .progress-bar__outer{border:1px solid var(--color-error)}.progress-bar--has-error .progress-bar__status-description{color:var(--color-error)}.progress-bar--disabled{cursor:not-allowed;opacity:0.5}.progress-bar--disabled .progress-bar__label{color:var(--color-disabled)}.progress-bar__label{display:block;padding:var(--spacing-label)}.progress-bar-wrapper{width:100%;display:flex;box-sizing:border-box;align-items:center}.progress-bar__outer{width:100%;height:var(--scl-spacing-8);margin:var(--scl-spacing-8);margin-left:0;overflow:hidden;position:relative;border-radius:100px;border:var(--border)}.progress-bar__inner{top:0;left:0;height:100%;display:flex;position:absolute;align-items:center;white-space:nowrap;justify-content:flex-end;animation-fill-mode:both;background:var(--background)}.progress-bar__inner-status{color:var(--color-inner-status);padding:0 12px;font-size:var(--font-size-inner-status)}.progress-bar__status{display:inline-block;font-size:var(--font-size-status);font-weight:var(--font-weight-status);color:var(--color-status)}.progress-bar__icon{height:16px}.progress-bar__status-description{color:var(--color-status-description);font-size:var(--font-size-status-description);font-weight:var(--font-weight-status-description)}.progress-bar__aria-live{clip:rect(0 0 0 0);width:1px;border:0;height:1px;margin:-1px;padding:0;overflow:hidden;position:absolute}";

let i$2 = 0;
const ProgressBar = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /** (optional) Progress bar busy switch */
    this.busy = false;
    /** (required) Progress bar percentage */
    this.percentage = 0;
    /** (optional) Progress bar stroke width */
    this.strokeWidth = 6;
    this.transitions = (width) => `
    @keyframes showProgress {
      from {
        width: 0;
      }
      to {
        width: ${width}%;
      }
    }
  `;
    this.progressStyle = () => {
      return {
        width: `${this.percentage}%`,
        border: '1px solid transparent',
        background: this.customColor,
        animation: 'showProgress 3s ease-in-out',
      };
    };
  }
  componentWillLoad() {
    if (this.progressBarId == null) {
      this.progressBarId = 'progress-bar-' + i$2++;
    }
  }
  componentWillUpdate() { }
  disconnectedCallback() { }
  render() {
    return (h(Host, null, this.styles && h("style", null, this.styles), h("style", null, this.transitions(this.percentage)), h("div", { part: this.getBasePartMap(), class: this.getCssClassMap() }, !!this.label && (h("label", { part: "label", class: "progress-bar__label", htmlFor: this.progressBarId }, this.label)), h("div", { part: "wrapper", class: "progress-bar-wrapper" }, h("div", { part: "outer", class: "progress-bar__outer", style: { height: `${this.strokeWidth}px` }, role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": this.percentage, "aria-busy": this.busy, "aria-valuetext": `${this.percentage}%`, "aria-label": this.label, id: this.progressBarId }, h("div", { part: "inner", class: "progress-bar__inner", style: this.progressStyle() }, !!this.statusInside && (h("div", { part: "inner-status", class: "progress-bar__inner-status", "aria-hidden": "true" }, this.percentage, "%")))), !!this.showStatus && (h("div", { part: "status", class: "progress-bar__status", "aria-hidden": "true" }, this.percentage, "%")), h("slot", { name: "icon" }))), !!this.statusDescription && (h("div", { part: "status-description", class: "progress-bar__status-description", role: "alert" }, this.statusDescription)), h("span", { "aria-live": "polite", class: "progress-bar__aria-live" }, this.percentage !== Math.round(this.percentage / 10) * 10
      ? `${Math.round(this.percentage / 10) * 10}%`
      : null)));
  }
  getBasePartMap() {
    return this.getCssOrBasePartMap('basePart');
  }
  getCssClassMap() {
    return this.getCssOrBasePartMap('css');
  }
  getCssOrBasePartMap(mode) {
    const component = 'progress-bar';
    const prefix = mode === 'basePart' ? '' : `${component}--`;
    return classnames(component, this.hasError && `${prefix}has-error`, this.disabled && `${prefix}disabled`);
  }
};
ProgressBar.style = progressBarCss;

const switchCss = ".switch{--size:20px;--offset:2px;--color-off:var(--scl-color-text-standard);--color-on:var(--scl-color-primary);--color-active:var(--scl-color-primary-active);--color-hover:var(--scl-color-primary-hover);--color-disabled:var(--scl-color-background-disabled);--color-state:var(--color-off);--color-state-contrast:var(--scl-color-background-standard);--color-background:var(--color-state-contrast);--color-toggle:var(--color-state);--color-text:var(--color-state);--transition-duration:var(--scl-motion-duration-fast);--transition-timing-function:var(--scl-motion-easing-standard);--box-shadow-focus:0 0 0 var(--scl-spacing-2) var(--scl-color-focus);--spacing-left:var(--scl-spacing-8);--font-weight:var(--scl-font-weight-medium);display:inline-block;position:relative}.switch label{cursor:pointer}.switch input{width:0;height:0;opacity:0;position:absolute}.switch .switch__wrapper{position:relative;border:1px solid var(--color-state);border-radius:calc(var(--size) / 2);width:calc(2 * var(--size) - var(--offset));height:calc(var(--size) - var(--offset));display:inline-flex;justify-content:space-between;background:var(--color-background);transition-property:background;transition-duration:var(--transition-duration);transition-timing-function:var(--transition-timing-function)}.switch .switch__text{display:flex;width:100%;color:var(--color-text);justify-content:space-evenly;font-size:var(--scl-font-size-12);line-height:calc(var(--size) - var(--offset));transition-property:color;transition-duration:var(--transition-duration);transition-timing-function:var(--transition-timing-function)}.switch .switch__text:before{content:'I'}.switch .switch__text:after{content:'0';position:relative;right:-1px}.switch .switch__toggle{position:absolute;border-radius:50%;padding:calc(0.5 * var(--size) - var(--offset));margin:calc(-0.5 * var(--size) + var(--offset));background:var(--color-toggle);left:calc(0.5 * var(--size) - 0.5 * var(--offset));top:50%;transition-property:transform, background;transition-duration:var(--transition-duration);transition-timing-function:var(--transition-timing-function)}.switch input:checked:disabled+.switch__wrapper .switch__toggle,.switch input:not(:checked):not(:disabled):active+.switch__wrapper .switch__toggle,.switch input:checked:not(:disabled):not(:active)+.switch__wrapper .switch__toggle{transform:translateX(var(--size))}.switch .switch__label{cursor:inherit;color:var(--color-text);margin-left:var(--spacing-left);font-weight:var(--font-weight);transition-property:color;transition-duration:var(--transition-duration);transition-timing-function:var(--transition-timing-function)}.switch--focus-visible-not-supported input:focus~.switch__wrapper{box-shadow:var(--box-shadow-focus)}.switch--focus-visible-supported input:focus-visible~.switch__wrapper{box-shadow:var(--box-shadow-focus)}.switch input:checked~.switch__wrapper{--color-state:var(--color-on);--color-background:var(--color-state);--color-toggle:var(--color-state-contrast);--color-text:var(--color-state-contrast)}.switch:hover,.switch:hover input~.switch__wrapper{--color-state:var(--color-hover)}.switch input:not(:disabled):active~.switch__wrapper{--color-state:var(--color-active);--color-background:var(--color-state);--color-toggle:var(--color-state-contrast);--color-text:var(--color-state-contrast)}.switch input:checked:not(:disabled):active~.switch__wrapper{--color-state:var(--color-active);--color-background:var(--color-state-contrast);--color-toggle:var(--color-active);--color-text:var(--color-active)}.switch input:not(:disabled):active~.switch__label{--color-text:var(--color-active)}.switch.switch--disabled{--color-state:var(--color-disabled);--color-hover:var(--color-disabled);--color-toggle:var(--color-disabled);--color-text:var(--color-disabled)}.switch.switch--disabled label{cursor:not-allowed}.switch.switch--disabled input:checked~.switch__wrapper{--color-state:var(--color-disabled);--color-toggle:var(--color-state-contrast);--color-text:var(--color-state-contrast)}";

let i$3 = 0;
// For chrome that applies :focus upon click, and :focus-visible isn't widely supported
const isFocusVisibleSupported = isPseudoClassSupported(':focus-visible');
const Switch = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.scaleChange = createEvent(this, "scaleChange", 7);
    /** (optional) Active switch */
    this.checked = false;
    /** (optional) Disabled switch */
    this.disabled = false;
  }
  componentWillLoad() {
    if (this.inputId == null) {
      this.inputId = 'switch-' + i$3++;
    }
  }
  render() {
    return (h(Host, null, h("div", { class: this.getCssClassMap() }, h("label", { id: `${this.inputId}-label` }, h("input", { type: "checkbox", checked: this.checked, disabled: this.disabled, "aria-pressed": this.checked, "aria-labelledby": `${this.inputId}-label`, id: this.inputId, onChange: (e) => {
        this.checked = e.target.checked;
        // bubble event through the shadow dom
        this.scaleChange.emit({ value: this.checked });
      } }), h("div", { class: "switch__wrapper" }, h("div", { class: "switch__toggle" }), h("div", { class: "switch__text" })), this.label && h("span", { class: "switch__label" }, this.label)))));
  }
  getCssClassMap() {
    return classnames('switch', this.disabled && 'switch--disabled', isFocusVisibleSupported && 'switch--focus-visible-supported', !isFocusVisibleSupported && 'switch--focus-visible-not-supported');
  }
};
Switch.style = switchCss;

const tagCss = ":host{--background:var(--scl-color-text-standard);--color:var(--scl-color-white);--font-size:var(--scl-font-variant-body-size);--line-height:var(--scl-font-variant-body-line-height);--font-weight:var(--scl-font-weight-bold);--radius:var(--scl-radius-4);--box-shadow-focus:0 0 0 var(--scl-spacing-2) var(--scl-color-focus);--icon-color:var(--color);--icon-color-hover:var(--scl-color-primary-active);--background-secondary:var(--scl-color-teal-80);--background-disabled:var(--scl-color-background-disabled);--color-disabled:var(--scl-color-grey-60);--spacing-left-dismissable:var(--scl-spacing-2);--border-button-dismissable-focus:1px solid\n    var(--scl-color-background-standard);--background-button-dismissable-focus:var(--scl-color-black);--box-shadow-button-dismissable-focus:var(--box-shadow-focus);--background-button-dismissable-hover:var(--scl-color-black);--height-button-dismissable-small:20px;--spacing-small:0 var(--scl-spacing-8);--font-size-small:var(--scl-font-size-12);--line-height-small:var(--scl-font-line-height-160)}.tag{border:1px solid transparent;display:inline-flex;outline:none;padding:0 10px;text-align:center;transition:all 0.15s ease-in-out;align-items:center;white-space:nowrap;border-radius:var(--scl-radius-4);vertical-align:baseline;justify-content:center;font-size:var(--font-size);line-height:var(--line-height);font-weight:var(--font-weight);background:var(--background);color:var(--color);cursor:default}.tag--variant-secondary{background:var(--background-secondary)}.tag scale-icon-action-close{color:var(--icon-color);transition:all 0.15s ease-in-out}.tag:not(.tag--disabled) scale-icon-action-close:hover{color:var(--icon-color-hover)}.tag--dismissable{padding-right:0}.tag--dismissable button{border:none;cursor:pointer;height:24px;margin:0;outline:none;padding:0;background:transparent;margin-left:var(--spacing-left-dismissable);border-radius:var(--radius)}.tag--dismissable scale-icon-action-close svg{outline:none}.tag--dismissable button:focus{border:var(--border-button-dismissable-focus);background:var(--background-button-dismissable-focus);box-shadow:var(--box-shadow-button-dismissable-focus)}.tag--dismissable button:hover{background:var(--background-button-dismissable-hover)}.tag--dismissable button:focus scale-icon-action-close{top:-1px;position:relative}.tag--size-small{padding:var(--spacing-small);font-size:var(--font-size-small);line-height:var(--line-height-small)}.tag--size-small.tag--dismissable{padding-right:0}.tag--size-small.tag--dismissable button{height:var(--height-button-dismissable-small)}.tag--variant-secondary.tag--dismissable{background:var(--background-secondary)}.tag--variant-secondary.tag--disabled{opacity:0.5}.tag--link{text-decoration:none}.tag--link:focus{border:1px solid white;box-shadow:var(--box-shadow-focus)}.tag--link.tag--variant-secondary{background:var(--background-secondary)}.tag--link.tag--variant-secondary:hover{background:var(--background-secondary)}.tag--link.tag--variant-secondary:focus{border:1px solid white}.tag--disabled{background:var(--background-disabled);color:var(--color-disabled);cursor:not-allowed;color:var(--color-disabled)}.tag--disabled scale-icon-action-close{color:var(--color-disabled)}.tag--disabled button{cursor:not-allowed}.tag--disabled button:hover{cursor:not-allowed;background:var(--background-disabled)}";

const Tag = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.scaleClose = createEvent(this, "scaleClose", 7);
    /** (optional) Tag size */
    this.size = '';
    /** (optional) Tag variant */
    this.variant = '';
    /** (optional) Tag href */
    this.href = '';
    /** (optional) Tag target */
    this.target = '_self';
    /** (optional) Tag dismissable */
    this.dismissable = false;
    /** (optional) Tag disabled */
    this.disabled = false;
    /** (optional) Dismiss label */
    this.dismissText = 'dismiss';
  }
  componentWillUpdate() { }
  disconnectedCallback() { }
  handleClose(event) {
    event.preventDefault();
    event.stopPropagation();
    this.scaleClose.emit(event);
  }
  render() {
    const Element = !!this.href && !this.disabled ? 'a' : 'span';
    const linkProps = !!this.href
      ? {
        href: this.href,
        target: this.target,
      }
      : {};
    const iconProps = !this.disabled
      ? {
        onClick: (event) => this.handleClose(event),
      }
      : {};
    return (h(Host, null, this.styles && h("style", null, this.styles), h(Element, Object.assign({ part: this.getBasePartMap(), class: this.getCssClassMap() }, linkProps), h("slot", null), this.dismissable && (h("button", { part: "button-dismissable", disabled: this.disabled, "aria-label": this.dismissText }, h("scale-icon-action-close", Object.assign({ part: "icon-dismissable", size: this.size === 'small' ? 20 : 24 }, iconProps)))))));
  }
  getBasePartMap() {
    return this.getCssOrBasePartMap('basePart');
  }
  getCssClassMap() {
    return this.getCssOrBasePartMap('css');
  }
  getCssOrBasePartMap(mode) {
    const component = 'tag';
    const prefix = mode === 'basePart' ? '' : `${component}--`;
    return classnames(mode === 'basePart' ? 'base' : component, this.size && `${prefix}size-${this.size}`, this.variant && `${prefix}variant-${this.variant}`, !!this.href && `${prefix}link`, !!this.dismissable && `${prefix}dismissable`, !!this.disabled && `${prefix}disabled`);
  }
};
Tag.style = tagCss;

const textFieldCss = "scale-text-field{--transition:all var(--scl-motion-duration-fast)\n    var(--scl-motion-easing-standard);--radius:var(--scl-radius-4);--border:var(--scl-spacing-1) solid var(--scl-color-text-standard);--border-error:var(--scl-spacing-2) solid var(--scl-color-background-error);--border-color-hover:var(--scl-color-primary-hover, #f90984);--border-color-focus:var(--scl-color-primary-hover, #f90984);--box-shadow-focus:0 0 0 var(--scl-spacing-2) var(--scl-color-focus);--height:var(--scl-spacing-48);--height-small:var(--scl-spacing-40);--spacing-x:var(--scl-spacing-12);--color-disabled:var(--scl-color-background-disabled);--background-disabled:var(--scl-color-white);--border-color-readonly:var(--scl-color-grey-0);--background-readonly:var(--scl-color-grey-0);--font-weight-meta:var(--scl-font-weight-bold);--font-size-meta:var(--scl-font-size-12);--line-height-meta:var(--scl-font-line-height-133);--spacing-y-meta:var(--scl-spacing-4);--color-meta:var(--scl-color-text-standard);--color-meta-error:var(--scl-color-text-error);--spacing-control:var(--scl-spacing-12) var(--spacing-x) 0\n    calc(var(--spacing-x) - 1px);--transition-control:var(--transition);--font-size-control:var(--scl-font-size-16);--transition-counter:var(--transition);--font-size-counter:var(--font-size-meta);--line-height-counter:var(--line-height-meta);--color-counter-error:var(--color-meta-error);--transition-helper-text:var(--transition);--font-size-helper-text:var(--font-size-meta);--line-height-helper-text:var(--line-height-meta);--color-helper-text:var(--scl-color-blue-70);--color-helper-text-error:var(--color-meta-error);--transition-placeholder:var(--transition);--color-placeholder:var(--scl-color-grey-60);--color-label:var(--scl-color-grey-60);--color-label-readonly:var(--scl-color-text-standard);--z-index-label:var(--scl-z-index-10);--transition-label:var(--transition);--font-size-label:var(--scl-font-size-16);--font-weight-label:var(--scl-font-weight-medium);--font-size-label-small:var(--scl-font-size-16);--font-weight-label-small:var(--scl-font-weight-medium);--font-size-label-focus:var(--scl-font-size-10);--font-weight-label-focus:var(--scl-font-weight-bold)}.text-field{position:relative}.text-field .text-field__helper-text,.text-field .text-field__counter{font-weight:var(--font-weight-meta)}.text-field .text-field__control{width:100%;height:var(--height);margin:0;display:flex;outline:none;padding:var(--spacing-control);z-index:1;box-sizing:border-box;transition:var(--transition-control);font-family:inherit;font-size:var(--font-size-control);border-radius:var(--radius);border:var(--border)}.text-field .text-field__counter{display:flex;transition:var(--transition-counter);margin-left:auto;padding-right:var(--spacing-x);justify-content:flex-end;font-size:var(--font-size-counter);line-height:var(--line-height-counter);color:inherit}.text-field .text-field__helper-text{transition:var(--transition-helper-text);padding-left:var(--spacing-x);font-size:var(--font-size-helper-text);line-height:var(--line-height-helper-text);color:var(--color-helper-text)}.text-field .text-field__meta{display:flex;justify-content:space-between;margin-top:var(--spacing-y-meta);color:var(--color-meta)}.text-field:not(.text-field--disabled):not(.text-field--readonly) .text-field__control:hover{border-color:var(--border-color-hover)}.text-field:not(.text-field--disabled):not(.text-field--readonly) .text-field__control:focus{border-color:var(--border-color-focus);box-shadow:var(--box-shadow-focus)}.text-field:not(.text-field--disabled) .text-field__control:focus::placeholder{color:var(--color-placeholder)}.text-field .text-field__control::placeholder,.text-field ::placeholder{color:transparent;transition:var(--transition-placeholder)}.text-field__label{top:0;left:0;color:var(--color-label);display:flex;z-index:var(--z-index-label);position:absolute;transition:var(--transition-label);pointer-events:none;font-size:var(--font-size-label);transform:translate(\n    var(--spacing-x),\n    calc((var(--height) - var(--font-size-label)) / 2)\n  );font-weight:var(--font-weight-label)}.text-field--has-focus:not(.text-field--readonly) .text-field__label,.animated .text-field__label{transform:translate(var(--spacing-x), var(--scl-spacing-8));font-size:var(--font-size-label-focus);font-weight:var(--font-weight-label-focus)}.text-field--status-error .text-field__control{border:var(--border-error)}.text-field--status-error .text-field__helper-text{color:var(--color-helper-text-error)}.text-field--status-error .text-field__counter{color:var(--color-counter-error)}.text-field--size-small .text-field__control{height:var(--height-small)}.text-field--size-small .text-field__label{font-size:var(--font-size-label-small);transform:translate(\n    var(--spacing-x),\n    calc((var(--height-small) - var(--font-size-label-small)) / 2)\n  );font-weight:var(--font-weight-label-small)}.text-field--size-small.text-field--has-focus:not(.text-field--readonly) .text-field__label,.text-field--size-small.animated .text-field__label{transform:translate(var(--spacing-x), var(--scl-spacing-4));font-size:var(--font-size-label-focus)}.text-field--transparent .text-field__control{background-color:transparent}.text-field--readonly input,.text-field--readonly .text-field__control{color:var(--color-label-readonly);border-color:var(--border-color-readonly);background:var(--background-readonly)}.text-field--readonly .text-field__control:focus{box-shadow:var(--box-shadow-focus)}.text-field--disabled label,.text-field--disabled .text-field__label,.text-field--disabled input,.text-field--disabled .text-field__control,.text-field--disabled .text-field__meta,.text-field--disabled .text-field__counter,.text-field--disabled .text-field__helper-text{cursor:not-allowed;border-color:var(--color-disabled);color:var(--color-disabled);background:var(--scl-color-white)}.text-field--disabled.animated label.text-field__label{color:var(--color-disabled)}input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{-webkit-appearance:none}input[type='number']{-moz-appearance:textfield}";

let i$4 = 0;
const TextField = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.scaleInput = createEvent(this, "scaleInput", 7);
    this.scaleChange = createEvent(this, "scaleChange", 7);
    this.scaleFocus = createEvent(this, "scaleFocus", 7);
    this.scaleBlur = createEvent(this, "scaleBlur", 7);
    this.scaleKeyDown = createEvent(this, "scaleKeyDown", 7);
    /** (optional) Input type */
    this.type = 'text';
    /** (optional) Input name */
    this.name = '';
    /** (optional) Input label */
    this.label = '';
    /** (optional) Input size */
    this.size = '';
    /** (optional) Input helper text */
    this.helperText = '';
    /** (optional) Input status */
    this.status = '';
    /** (optional) Input placeHolder */
    this.placeholder = '';
    /** (optional) Input value */
    this.value = '';
    /** Whether the input element has focus */
    this.hasFocus = false;
    this.handleInput = (event) => {
      const target = event.target;
      if (target) {
        this.value = target.value || '';
        this.emitChange();
      }
      this.scaleInput.emit(event);
    };
    this.handleChange = (event) => {
      const target = event.target;
      if (target) {
        this.value = target.value || '';
        this.emitChange();
      }
    };
    this.handleFocus = () => {
      this.scaleFocus.emit();
      this.hasFocus = true;
    };
    this.handleBlur = () => {
      this.scaleBlur.emit();
      this.hasFocus = false;
    };
    this.handleKeyDown = (event) => {
      this.scaleKeyDown.emit(event);
    };
  }
  componentWillLoad() {
    if (this.inputId == null) {
      this.inputId = 'input-text-field' + i$4++;
    }
  }
  // We're not watching `value` like we used to
  // because we get unwanted `scaleChange` events
  // because how we keep this.value up-to-date for type="select"
  // `this.value = selectedValue`
  emitChange() {
    this.scaleChange.emit({
      value: this.value == null ? this.value : this.value.toString(),
    });
  }
  render() {
    const ariaInvalidAttr = this.status === 'error' ? { 'aria-invalid': true } : {};
    const helperTextId = `helper-message-${i$4}`;
    const ariaDescribedByAttr = { 'aria-describedBy': helperTextId };
    return (h(Host, null, this.styles && h("style", null, this.styles), h("div", { class: this.getCssClassMap() }, h("label", { class: "text-field__label", htmlFor: this.inputId }, this.label), h("input", Object.assign({ type: this.type, class: "text-field__control", value: this.value }, (!!this.name ? { name: this.name } : {}), { required: this.required, minLength: this.minLength, maxLength: this.maxLength, id: this.inputId, onInput: this.handleInput, onChange: this.handleChange, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown }, (!!this.placeholder ? { placeholder: this.placeholder } : {}), { disabled: this.disabled, readonly: this.readonly }, ariaInvalidAttr, ariaDescribedByAttr)), (!!this.helperText || !!this.counter) && (h("div", { class: "text-field__meta", id: helperTextId, "aria-live": "polite", "aria-relevant": "additions removals" }, !!this.helperText && (h("div", { class: "text-field__helper-text" }, this.helperText)), this.counter && (h("div", { class: "text-field__counter" }, !!this.value ? String(this.value).length : 0, " /", ' ', this.maxLength)))))));
  }
  getCssClassMap() {
    // input[type="date"] will print a placeholder in some browsers
    const animated = (this.value != null && this.value !== '') || this.type === 'date';
    return classnames('text-field', this.type && `text-field--type-${this.type}`, this.hasFocus && 'text-field--has-focus', this.disabled && `text-field--disabled`, this.transparent && 'text-field--transparent', this.status && `text-field--status-${this.status}`, this.size && `text-field--size-${this.size}`, this.readonly && `text-field--readonly`, animated && 'animated');
  }
};
TextField.style = textFieldCss;

export { Button as scale_button, Checkbox as scale_checkbox, Dropdown as scale_dropdown, ActionHidePassword as scale_icon_action_hide_password, ActionSort as scale_icon_action_sort, NavigationCollapseUp as scale_icon_navigation_collapse_up, ServiceSettings as scale_icon_service_settings, Link as scale_link, MenuFlyout as scale_menu_flyout, MenuFlyoutItem as scale_menu_flyout_item, MenuFlyoutList as scale_menu_flyout_list, Pagination as scale_pagination, ProgressBar as scale_progress_bar, Switch as scale_switch, Tag as scale_tag, TextField as scale_text_field };
